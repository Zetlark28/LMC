(defun one-instruction (state)
  (cond ((null state) nil)
  	((eq (nth 0 state) 'halted-state) (nil))
        ((= (which-instruction state) 1) (add-max state))
        ((= (which-instruction state) 2) (sub-inf state))
 (T nil)))
        
         









(defun which-instruction (state)
  (floor (nth (nth 4 state) (nth 6 state)) 100))

(defun mem-instruction (state)
  (mod (nth (nth 4 state) (nth 6 state)) 100))


(defun add-max (state)
	(cond 
		((> (+ (nth 2 state) (nth (mem-instruction state) (nth 6 state))) 1000)
			((lambda (acc flag pc)
				(list 'STATE 
				:acc acc 
				:pc pc 
				:mem (nth 6 state)
				:in (nth 8 state)
				:out (nth 10 state)
				:flag flag ))
				(mod (+ (nth 2 state) (nth (mem-instruction state) (nth 6 state))) 1000) 'flag (1+ (nth 4 state))))

                (T (add-min state))))


(defun add-min (state)
  ((lambda (acc flag pc)
	   (list 'STATE 
	   :acc acc 
           :pc pc 
           :mem (nth 6 state)
	   :in (nth 8 state)
	   :out (nth 10 state)
	   :flag flag ))
	   (+ (nth 2 state) (nth (mem-instruction state) (nth 6 state))) 'noflag (1+ (nth 4 state))))


(defun sub-inf (state)
   (cond (< (- (nth (mem-instruction state) (nth 6 state)) (nth 2 state)) 0)
        ((lambda (acc flag pc)
            (list 'STATE 
            :acc acc
            :pc pc
            :mem (nth 6 state)
            :in (nth 8 state)
            :out (nth 10 state)
            :flag flag ))
            (+ (- (nth (mem-instruction state) (nth 6 state)) (nth 2 state)) 1000) 'flag (1+ (nth 4 state))))

     (T (sub-sup state))))

(defun sub-sup (state)
    ((lambda (acc flag pc)
            (list 'STATE 
            :acc acc
            :pc pc 
            :mem (nth 6 state)
            :in (nth 8 state)
            :out (nth 10 state)
            :flag flag ))
            (- (nth (mem-instruction state) (nth 6 state)) (nth 2 state) 'noflag (1+ (nth 4 state))))
